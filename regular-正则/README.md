## 迷你版正则表达式

## 内容匹配

### 模糊匹配

- {m, n} 横向模糊匹配 例如：表示连续出现至少 m 次，最多 n 次。/ab{2, 5}c/g

```js
const str = 'a22c a222c a2222c'
// 匹配连续出现的数字[0-9]范围内的，至少出现2次，最多三次
console.log(str.match(/a\d{2,3}c/gi))
```

- [xxx] 纵向模糊匹配，比如：[abc]可以匹配到 a，b，c 任意一种，/a[123]b/ 可以匹配 a1b a2b a3b

```js
const str1 = 'a1b a2b a3b a4b'
// 匹配字符组中1，2，3任意数值
console.log(str1.match(/a[123]b/gi))
```

### 字符组

#### 范围表示

- 虽然叫字符组，但是匹配的是其中一个字符串，例如：[abc]，匹配的是 a，b，c 任意字符
- 如果想表示范围可以是：[1-6a-z], [1-9]等
- 如果想匹配- 不能直接写。因为-在正则中有特殊函数，可以直接写[\-], 需要经过转义

```js
const str2 = 'a1234b a23456b'
// [1-4]+ 匹配1-4中任意值，至少出现一次
console.log(str2.match(/a[1-4]+b/gi))
```

#### 排除字符组

- 纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 "a"、"b"、"c"
- 此时就是排除字符组（反义字符组）的概念。例如 [^abc]，表示是一个除 "a"、"b"、"c"之外的任意一个字符。字符组的第一位放 ^（脱字符），表示求反的概念

```js
const str3 = 'a1b a2b a3b a4b'
// 在字符组中前面添加^ 表示筛选内容取反
console.log(str3.match(/a[^1-3]b/gi))
```

#### 简写格式

- \d 表示 [0-9]。表示是一位数字
- \D 表示 [^0-9]。表示除数字外的任意字符
- \w 表示 [0-9a-zA-Z_]。表示数字、大小写字母和下划线
- \W 表示 [^0-9a-za-z_]。非单词字符
- \s 表示 [ \t\v\n\r\f]。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符
- \S 表示 [^ \t\v\n\r\f]。 非空白符
- . 表示 [^\n\r\u2028\u2029]。通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外
- 如果要匹配任意字符怎么办？可以使用 [\d\D]、[\w\W]、[\s\S] 和 [^] 中任何的一个

```js
const str4 = 'sdf7897sdf()'
console.log(str4.match(/[\d\D]+/gi))
console.log(str4.match(/.+/gi))
```

#### 量词

- {m,} 表示至少出现 m 次
- {m, n} 表示至少出现 m 次，最多出现 n 次
- {m} 等价于 {m,m}，表示出现 m 次
- ? 等价于 {0,1}，表示出现或者不出现
- 等价于 {1,}，表示出现至少一次
- \* 等价于 {0,}，表示出现任意次，有可能不出现

#### 贪婪匹配 与 惰性匹配

- 通过在量词后面加个问号就能实现惰性匹配
- 惰性量词 => {m, n}? 贪婪量词 => {m, n}
- 惰性量词 => {m,}? 贪婪量词 => {m,}
- 惰性量词 => ?? 贪婪量词 => ?
- 惰性量词 => +? 贪婪量词 => +
- 惰性量词 => _? 贪婪量词 => _

```js
const str5 = 'a22c a222c a2222c'
// 量词后面添加? 表示惰性匹配 会尽可能的少匹配
console.log(str5.match(/a\d{2,4}?/gi))
const str6 = 'a12dgs344'
console.log(str6.match(/.+?/gi))
```

### 多选分支

- 一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一
- 具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一
- 分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了

## 位置匹配

### 匹配位置的锚

- ^ 匹配开头，在多行匹配中匹配行开头
- $ 匹配结尾，在多行匹配中匹配行结尾
- \b 是单词边界，具体就是 \w 与 \W 之间的位置，也包括 \w 与 ^ 之间的位置，和 \w 与 $ 之间的位置
- \B 是 \b 的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉 \b，剩下的都是 \B 的。具体说来就是 \w 与 \w、 \W 与 \W、^ 与 \W，\W 与 $ 之间的位置
- (?=p) 其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p 正向先行断言
- (?!p) 就是 (?=p) 的反面意思 负向先行断言

## 正则表达式括号

### 分组

- 我们知道 /a+/ 匹配连续出现的 "a"，而要匹配连续出现的 "ab" 时，需要使用 /(ab)+/
- 其中括号是提供分组功能，使量词 + 作用于 "ab" 这个整体，测试如下

### 分支结构

- 而在多选分支结构 (p1|p2) 中，此处括号的作用也是不言而喻的，提供了分支表达式的所有可能

### 分组引用

- 这是括号一个重要的作用，有了它，我们就可以进行数据提取，以及更强
  大的替换操作
- 而要使用它带来的好处，必须配合使用实现环境的 API

```js
// 表示提取数据
const str14 = '2017-06-12'
const reg1 = /\d{4}-\d{2}-\d{2}/
const reg2 = /(\d{4})-(\d{2})-(\d{2})/
console.log(str14.match(reg1))
console.log(str14.match(reg2))

// 分组引用替换
console.log(str14.replace(reg2, '$2/$3/$1'))
```

### 反向引用

- 除了使用相应 API 来引用分组，也可以在正则本身里引用分组。但只能引用之前出现的分组，即反向引用
- 如果真要匹配 \1 和 0 的话，请使用 (?:\1)0 或者 \1(?:0)。
- 分组后面有量词的话，分组最终捕获到的数据是最后一次的匹配。

```js
// 匹配字符
// 2016-06-12
// 2016/06/12
// 2016.06.12

// 失败的正则
var regex = /\d{4}(-|\/|\.)\d{2}(-|\/|\.)\d{2}/
// 通过上述正则
// 2016/06.12 true
// 2016/06/12 true

// 对正则进行引用 使前后符号保持一致
var regex1 = /\d{4}(-|\/|\.)\d{2}\1\d{2}/
```

#### 非捕获括号

- 之前文中出现的括号，都会捕获它们匹配到的数据，以便后续引用，因此也称它们是捕获型分组和捕获型分支
- 如果只想要括号最原始的功能，但不会引用它，即，既不在 API 里引用，也不在正则里反向引用。此时可以使用非捕获括号 (?:p) 和 (?:p1|p2|p3)，例如本章第一个例子可以修改为：

```js
// 单词首字母变大写
const str17 = 'my name is epeli'
const str18 = str17.replace(/(?:^|\s)[a-z]/g, function (c) {
  return c.toUpperCase()
})
```

## 需要转移的字符串

```js
// ^、$、.、*、+、?、|、\、/、(、)、[、]、{、}、=、!、:、-
```
